# Вопросы и ответы по лабораторной работе 3

## Вопрос 1: Что такое IEnumerable и для чего он нужен?

**Ответ:**
- `IEnumerable<T>` — это интерфейс, который позволяет перебирать элементы коллекции
- Он определяет метод `GetEnumerator()`, который возвращает `IEnumerator<T>`
- Оператор `foreach` использует `IEnumerable` для итерации по коллекции
- Можно реализовать `foreach` без `IEnumerable`, используя напрямую `IEnumerator`, но это менее удобно

**Связь IEnumerable, IEnumerator и foreach:**
- `IEnumerable` предоставляет метод `GetEnumerator()`, который возвращает `IEnumerator`
- `IEnumerator` содержит методы `MoveNext()`, `Current` и `Reset()`
- `foreach` компилятор преобразует в вызов `GetEnumerator()` и цикл с `MoveNext()` и `Current`

## Вопрос 2: Чем отличается ICollection от IList?

**Ответ:**
- **ICollection<T>** — базовый интерфейс, который добавляет к `IEnumerable`:
  - `Count` — количество элементов
  - `Add`, `Remove`, `Clear` — базовые операции
  - `Contains` — проверка наличия элемента
  - `CopyTo` — копирование в массив
  - `IsReadOnly` — флаг только для чтения

- **IList<T>** — наследует `ICollection<T>` и добавляет:
  - Индексатор `this[int index]` — доступ по индексу
  - `Insert(int index, T item)` — вставка по индексу
  - `RemoveAt(int index)` — удаление по индексу
  - `IndexOf(T item)` — поиск индекса элемента

**Когда использовать:**
- `ICollection` — когда нужны базовые операции, но не важен порядок или доступ по индексу
- `IList` — когда нужен упорядоченный доступ к элементам по индексу

## Вопрос 3: Что такое IDictionary<TKey, TValue>?

**Ответ:**
- `IDictionary<TKey, TValue>` — интерфейс для работы с парами ключ-значение
- Основные операции:
  - `Add(TKey key, TValue value)` — добавление пары
  - `Remove(TKey key)` — удаление по ключу
  - `ContainsKey(TKey key)` — проверка наличия ключа
  - `TryGetValue(TKey key, out TValue value)` — безопасное получение значения
  - Индексатор `this[TKey key]` — доступ по ключу
  - `Keys` и `Values` — коллекции ключей и значений

**Отличие от списка:**
- Список хранит элементы последовательно с доступом по индексу
- Словарь хранит пары ключ-значение с доступом по ключу (обычно через хеш-таблицу)
- Словарь обеспечивает быстрый поиск O(1) в среднем случае

## Вопрос 4: Как реализован метод GetEnumerator() в вашем SimpleList?

**Ответ:**
В `SimpleList` метод `GetEnumerator()` реализован с использованием `yield return`:

```csharp
public IEnumerator<T> GetEnumerator()
{
    for (int i = 0; i < _count; i++)
    {
        yield return _items[i];
    }
}
```

**Почему возвращается IEnumerator, а не IEnumerable:**
- `IEnumerator` — это объект, который хранит состояние итерации (текущую позицию)
- `IEnumerable` — это фабрика, которая создает новый `IEnumerator` при каждом вызове
- Возврат `IEnumerator` позволяет компилятору оптимизировать `foreach` циклы

**Что такое yield return:**
- `yield return` — синтаксический сахар C# для создания итераторов
- Компилятор автоматически создает класс, реализующий `IEnumerator`
- Упрощает написание итераторов без явного создания класса-итератора

## Вопрос 5: Как работает метод Add в ICollection?

**Ответ:**
В `SimpleList` метод `Add` работает следующим образом:

```csharp
public void Add(T item)
{
    if (_count >= _items.Length)
    {
        Resize();
    }
    _items[_count] = item;
    _count++;
}
```

**Что происходит при добавлении в полный массив:**
- Вызывается метод `Resize()`, который создает новый массив в 2 раза больше
- Все элементы копируются в новый массив
- Старый массив освобождается сборщиком мусора

**Сложность операции добавления в конец:**
- В среднем случае: O(1) — амортизированная сложность
- В худшем случае (при переаллокации): O(n) — нужно скопировать все элементы
- Благодаря удвоению размера массива, переаллокация происходит редко, поэтому средняя сложность остается O(1)

## Вопрос 6: Как реализован метод Remove в IList?

**Ответ:**
В `SimpleList` метод `RemoveAt` реализован так:

```csharp
public void RemoveAt(int index)
{
    if (index < 0 || index >= _count)
        throw new ArgumentOutOfRangeException(nameof(index));

    _count--;
    if (index < _count)
    {
        Array.Copy(_items, index + 1, _items, index, _count - index);
    }
    _items[_count] = default(T)!;
}
```

**Что происходит с элементами после удаления:**
- Все элементы после удаленного индекса сдвигаются влево на одну позицию
- Используется `Array.Copy` для эффективного копирования блока элементов
- Последний элемент обнуляется (для ссылочных типов — устанавливается в `null`)

**Почему удаление из середины медленнее удаления из конца:**
- Удаление из конца: O(1) — просто уменьшаем счетчик
- Удаление из середины: O(n) — нужно сдвинуть все элементы после удаленного
- В `DoublyLinkedList` удаление из середины также O(n), но не требует сдвига массива, только обновление ссылок
