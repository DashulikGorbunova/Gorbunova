# Лабораторная работа 4. Синхронизация потоков

**Тема**: Синхронизация потоков, deadlock, starvation

## Цель работы

Изучить проблему синхронизации потоков, научиться выявлять и предотвращать взаимоблокировки (deadlock).

## Задачи

### 1. Обедающие философы (Dining Philosophers)

**Цель**: Избежать deadlock и starvation.

**Требования**:
- 5 философов, 5 вилок
- Каждый философ — отдельный поток
- Философы могут думать и есть
- Для еды нужны ДВЕ вилки (левая и правая)

**Реализовано ДВА решения**:
1. **С deadlock** (как пример неправильной реализации)
   - Каждый философ сначала берёт левую вилку, затем правую
   - Это приводит к deadlock, когда все философы берут левую вилку одновременно
   
2. **Без deadlock** (исправленная версия)
   - Используется упорядочивание ресурсов
   - Все философы, кроме последнего, берут сначала левую, затем правую вилку
   - Последний философ берёт сначала правую, затем левую вилку
   - Это предотвращает циклическое ожидание

**Используемые инструменты**: `lock`

### 2. Задача о спящем парикмахере (Sleeping Barber)

**Описание**:
- В парикмахерскую приходят клиенты
- Парикмахер:
  - если клиентов нет — спит
  - если клиент пришёл — парикмахер работает
- Очередь ограничена

**Цель**: Смоделировать поведение через многопоточность.

**Используется**:
- `SemaphoreSlim` — для синхронизации парикмахера и клиентов
- `Mutex` — для защиты критической секции (очередь)
- `ConcurrentQueue<T>` — очередь, доступная из разных потоков

### 3. Производитель–Потребитель (Producer–Consumer)

**Описание**:
- Есть буфер (ограниченная очередь)
- Производители добавляют товары, потребители забирают

**Цель**:
- Обеспечить правильную синхронизацию
- Не переполнить буфер
- Не забирать из пустого

**Реализовано ДВА решения**:
1. **BlockingCollection** (готовое решение)
   - Использует встроенную коллекцию .NET
   - Автоматически обрабатывает синхронизацию

2. **SemaphoreSlim + lock** (ручная синхронизация)
   - Два семафора: для свободных и заполненных мест
   - `lock` для защиты критической секции (буфер)

## Структура проекта

- **src/Lab04** – консольное приложение с основной логикой:
  - `Services/DiningPhilosophers.cs` – задача об обедающих философах
  - `Services/SleepingBarber.cs` – задача о спящем парикмахере
  - `Services/ProducerConsumer.cs` – задача производитель-потребитель
  - `Program.cs` – точка входа приложения с меню выбора задач

## Используемые технологии и библиотеки

- **.NET 8.0**
- **System.Threading** для синхронизации потоков
- **System.Collections.Concurrent** для потокобезопасных коллекций

## Как запустить

1. Открыть папку `lab04` в терминале.
2. Выполнить сборку:

```bash
dotnet build Lab04.sln
```

3. Запустить консольное приложение:

```bash
dotnet run --project src/Lab04/Lab04.csproj
```

4. В меню выбрать нужную задачу:
   - `1` - Обедающие философы (с deadlock)
   - `2` - Обедающие философы (без deadlock)
   - `3` - Спящий парикмахер
   - `4` - Производитель-Потребитель (BlockingCollection)
   - `5` - Производитель-Потребитель (SemaphoreSlim + lock)
   - `0` - Выход

## Критерии оценки

- ✅ Наглядно показан deadlock в первой версии обедающих философов
- ✅ Корректная работа во второй версии обедающих философов
- ✅ Использование `lock` или `SemaphoreSlim` в реализациях
- ✅ Корректная реализация задачи о спящем парикмахере
- ✅ Корректная реализация задачи производитель-потребитель (два варианта)

## Примерные вопросы на защите

См. файл `QuestionAnswers.md` для ответов на вопросы:
1. Что такое race condition (состояние гонки)? Приведите пример из вашей задачи.
2. Чем deadlock отличается от starvation? Где может возникнуть каждое из этих явлений в вашей реализации?
3. Что такое критическая секция? Где она находится в вашем коде?
4. Объясните разницу между:
   - `lock` и `Monitor`
   - `Mutex` и `SemaphoreSlim`
   - `Semaphore` и `SemaphoreSlim`

