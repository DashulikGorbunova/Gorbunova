# Вопросы и ответы по лабораторной работе 2

## Вопрос 1: Почему List<T>.Insert(0, item) медленнее LinkedList<T>.AddFirst(item)?

**Ответ:** 
- `List<T>.Insert(0, item)` имеет сложность O(n), так как нужно сдвинуть все существующие элементы вправо для освобождения места в начале массива.
- `LinkedList<T>.AddFirst(item)` имеет сложность O(1), так как просто создается новый узел и обновляются ссылки на первый элемент.
- LinkedList не хранит элементы в непрерывной памяти, поэтому не требует перемещения элементов.

## Вопрос 2: В каких случаях ImmutableList<T> предпочтительнее обычного List<T>?

**Ответ:**
- Когда нужна потокобезопасность без использования блокировок
- Когда нужно сохранить историю изменений (каждая операция создает новую версию)
- В функциональном программировании, где неизменяемость является принципом
- Когда коллекция передается между потоками и не должна изменяться
- В многопоточных приложениях, где несколько потоков читают данные

## Вопрос 3: Как List<T> реализует амортизированную O(1) для добавления?

**Ответ:**
- List<T> использует динамический массив с начальной емкостью (Capacity)
- При добавлении элементов, если места достаточно, добавление происходит за O(1)
- Когда массив заполняется, выделяется новый массив большего размера (обычно в 2 раза), все элементы копируются - это O(n)
- Но так как переаллокация происходит редко (при достижении Capacity), средняя стоимость добавления остается O(1) - это амортизированная сложность
- Можно предварительно установить Capacity для уменьшения переаллокаций

## Вопрос 4: Почему поиск в LinkedList<T> медленнее, чем в List<T>?

**Ответ:**
- В `List<T>` элементы хранятся в непрерывной памяти массива, что обеспечивает хорошую локальность данных и эффективное использование кэша процессора
- В `LinkedList<T>` элементы разбросаны по памяти, каждый узел содержит указатели на следующий и предыдущий элементы
- При поиске в LinkedList нужно последовательно проходить по узлам, что приводит к множественным промахам кэша
- Оба имеют сложность O(n), но List<T> работает быстрее из-за лучшей производительности кэша

## Вопрос 5: Когда стоит использовать предварительное выделение Capacity?

**Ответ:**
- Когда известно приблизительное или точное количество элементов, которые будут добавлены
- Это уменьшает количество переаллокаций массива в List<T>
- Особенно важно при работе с большими коллекциями (десятки тысяч элементов)
- Пример: `var list = new List<int>(100000);` - сразу выделит память на 100000 элементов

## Вопрос 6: Как Queue<T> реализует эффективное удаление из начала?

**Ответ:**
- Queue<T> использует циклический буфер (circular buffer) на основе массива
- Вместо физического удаления элемента из начала массива, просто сдвигается указатель на начало очереди
- Это позволяет избежать перемещения всех элементов, как в List<T>
- Операции Enqueue и Dequeue выполняются за O(1)
- Когда буфер заполняется, происходит переаллокация, но это происходит редко

## Вопрос 7: В чем разница между IEnumerable, ICollection и IList?

**Ответ:**
- **IEnumerable<T>** - базовый интерфейс, позволяет только перечислять элементы (foreach), имеет метод GetEnumerator()
- **ICollection<T>** - наследует IEnumerable, добавляет Count, Add, Remove, Clear, Contains - базовые операции с коллекцией
- **IList<T>** - наследует ICollection, добавляет доступ по индексу (индексатор, Insert, RemoveAt, IndexOf) - упорядоченная коллекция с индексацией
- Иерархия: IEnumerable < ICollection < IList
- Каждый следующий интерфейс добавляет больше функциональности

## Вопрос 8: Как выбор коллекции влияет на работу Garbage Collector?

**Ответ:**
- **List<T>** - создает массивы, которые являются большими объектами (LOH) при размере >85KB, такие объекты собираются реже и могут вызывать паузы
- **LinkedList<T>** - создает множество маленьких объектов (узлов), увеличивает нагрузку на GC из-за частых сборок мусора
- **ImmutableList<T>** - создает много промежуточных объектов при операциях, увеличивает нагрузку на GC, но обеспечивает потокобезопасность
- **Queue<T> и Stack<T>** - используют массивы, похожи на List<T> по влиянию на GC
- Предварительное выделение Capacity уменьшает количество переаллокаций и снижает нагрузку на GC
